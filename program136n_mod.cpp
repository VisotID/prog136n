// Автор:Высоцкая Инесса Д.
// program136n_mod.cpp
// часть модуля (файл, содержащий тела функций)
#include <iostream> // библиотека С++, отвечающая за чтение и запись(для функций cin - функция чтения, cout - функция вывода)
#include <cmath> // математическая библиотека С++(функции sqrt - квадратный корень, abs - модуль)
#include <cassert> // библиотека С++ для обнаружения логических ошибок в программе(для функции assert)
#include <fstream> // библиотека С++ для работы с файлами(функции ofstream - открытие\создание файла для записи и ifstream - открытие файла для чтения)
#include <vector> // библиотека С++ для работы с векторами

using namespace std; // используем пространство имен std для того, чтобы не писать перед функциями cin, cout "std"
namespace operate_array // создаём самостоятельно пространство имён для модуля(пространство имён (namespace) позволяет группировать идентификаторы в отдельные области, что помогает избежать конфликтов имён)
{
/// Функция вывода массива на экран
/// array_num - массив, передаваемый по ссылке, n - количество элементов в массиве
void print_array(float *array_num, size_t n)
{
    for(size_t i = 0; i < n; i++) // цикл для прохождения по всему массиву
    {
        cout << array_num[i] << " "; // вывод массива на экран(функция вывода << "то, что выводим"), << - операция вставки 
    }
}

/// Функция вывода массива на экран(вектор)
/// const vector<float> &array_num - массив, передаваемый по ссылке типа вектор float, const чтобы не изменить массив
void print_array(const vector<float> &array_num)
{
    for(size_t i = 0; i < array_num.size(); i++) // цикл для прохождения по всему массиву
    {
        cout << array_num[i] << " "; // вывод массива на экран(функция вывода << "то, что выводим"), << - операция вставки 
    }
}

/// Функция заполнения массива вручную
/// array_num - массив, передаваемый по ссылке, n - количество элементов в массиве
void input_hand_array(float *array_num, size_t n)
{
    for(size_t i = 0; i < n; i++) // цикл для прохождения по всему массиву
    {
        cout << "Введите " << i << " элемент: "; // вывод на экран(функция вывода << "то, что выводим" ), << - операция вставки 
        cin >> array_num[i]; // чтение i-го элемента с консоли
    }
}

/// Функция заполнения массива вручную (вектор)
/// vector<float> &array_num - массив, передаваемый по ссылке типа вектор float
void input_hand_array(vector<float> &array_num)
{
    for(size_t i = 0; i < array_num.size(); i++) // цикл для прохождения по всему массиву
    {
        cout << "Введите " << i << " элемент: "; // вывод на экран(функция вывода << "то, что выводим" ), << - операция вставки 
        cin >> array_num[i]; // чтение i-го элемента с консоли
    }
}

/// Функция заполнения массива рандомными числами
/// array_num - массив, передаваемый по ссылке, n - количество элементов в массиве
void input_array(float *array_num, size_t n)
{
    for(size_t i = 0; i < n; i++) // цикл для прохождения по всему массиву
    {
        array_num[i] = (rand() % 30-15); // рандомно задаём элементы массива в диапазоне от -15 до 15(элемент = функция rand отвечает за генерацию случайных чисел, делим на 30 и вычитаем 15, чтобы задать диапазон чисел)
    }
}

/// Функция заполнения массива рандомными числами (вектор)
/// vector<float> &array_num - массив, передаваемый по ссылке типа вектор float
void input_array(vector<float> &array_num)
{
    for(size_t i = 0; i < array_num.size(); i++) // цикл для прохождения по всему массиву
    {
        array_num[i] = (rand() % 30-15); // рандомно задаём элементы массива в диапазоне от -15 до 15(элемент = функция rand отвечает за генерацию случайных чисел, делим на 30 и вычитаем 15, чтобы задать диапазон чисел)
    }
}

/// Функция, возвращающая результат вычисления по формуле (sqrt(|a1|)-a1)^2+...+(sqrt(|an|)-an)^2
/// array_num - массив, передаваемый по ссылке, n - количество элементов в массиве
float sum_array(float *array_num, size_t n)
{
    float rezult = 0; // задаём первоначальное значение
    for(size_t i = 0; i < n; i++) // цикл для прохождения по всему массиву
    {
        rezult += (sqrt(fabs(array_num[i]))-array_num[i])*(sqrt(fabs(array_num[i]))-array_num[i]); // вычисление по формуле (sqrt(|a1|)-a1)^2+...+(sqrt(|an|)-an)^2
    }
    return rezult; // возвращение результата вычислений
}

/// Функция, возвращающая результат вычисления по формуле (sqrt(|a1|)-a1)^2+...+(sqrt(|an|)-an)^2 (вектор)
/// const vector<float> &array_num - массив, передаваемый по ссылке типа вектор float, const чтобы не изменить массив
float sum_array(const vector<float> &array_num)
{
    float rezult = 0; // задаём первоначальное значение
    for(size_t i = 0; i < array_num.size(); i++) // цикл для прохождения по всему массиву
    {
        rezult += (sqrt(fabs(array_num[i]))-array_num[i])*(sqrt(fabs(array_num[i]))-array_num[i]); // вычисление по формуле (sqrt(|a1|)-a1)^2+...+(sqrt(|an|)-an)^2
    }
    return rezult; // возвращение результата вычислений
}

/// Функция сохранения массива в файл
/// const char* name - имя файла, array_num - массив, передаваемый по ссылке, n - количество элементов в массиве
void array_in_file(const char* name, float *array_num, size_t n)
{
    ofstream files(name); // открываем или создаём файл для записи
    if (files.is_open() == false) // если файл не удалось открыть
    {
        cout << " Не удалось открыть файл " << name << "\n"; // вывод на экран сообщения об ошибке
        return; // завершение работы функции
    }
    for (size_t i = 0; i < n; i++) // цикл для прохождения по всему массиву
    {
        files << array_num[i] << " "; // запись элементов массива через пробел в файл
    }
    files.close(); // закрытие файла
}

/// Функция сохранения массива в файл (вектор)
/// const char* name - имя файла, const vector<float> &array_num - массив, передаваемый по ссылке типа вектор float, const чтобы не изменить массив
void array_in_file(const char* name, const vector<float> &array_num)
{
    ofstream files(name); // открываем или создаём файл для записи
    if (files.is_open() == false) // если файл не удалось открыть
    {
        cout << " Не удалось открыть файл " << name << "\n"; // вывод на экран сообщения об ошибке
        return; // завершение работы функции
    }
    for (size_t i = 0; i < array_num.size(); i++) // цикл для прохождения по всему массиву
    {
        files << array_num[i] << " "; // запись элементов массива через пробел в файл
    }
    files.close(); // закрытие файла
}

/// Функция загрузки массива из файла
/// const char* name - имя файла, n - количество элементов в массиве, передаём по ссылке для изменения
float *array_out_file(const char* name, size_t &n)
{
    n = 0; // изменяем размер массива на 0
    ifstream filel(name); // открытие файла для чтения
    if (filel.is_open() == false) // если файл не открылся
    {
        cout << " Не удалось открыть файл " << name << "\n"; // вывод на экран сообщения об ошибке
        return nullptr; // завершение работы функции
    }
    float tsize; // временная переменная для кол-ва элементов массива из файла
    while (filel >> tsize) // цикл для подсчёта количества элементов в файле
    {
        n++; // увеличение на 1
    }
    filel.clear(); // "очищение" состояния файлового потока
    filel.seekg(0); // перемещение указателя на начало файла
    float *array_num = new float[n]; // выделение памяти под временный массив
    for (size_t i = 0; i < n; i++) // цикл для перемещения по файлу
    {
        filel >> array_num[i]; // считывание элементов массива из файла во временный массив
    }
    filel.close(); // закрытие файла
    return array_num; // возвращаем массив
}

/// Функция загрузки массива из файла (вектор)
/// const char* name - имя файла, vector<float> &array_num - массив, передаваемый по ссылке типа вектор float, n - количество элементов в массиве, передаём по ссылке для изменения
void array_out_file(const char* name, vector<float> &array_num, size_t &n)
{
    n = 0; // изменяем размер массива на 0
    ifstream filel(name); // открытие файла для чтения
    if (filel.is_open() == false) // если файл не открылся
    {
        cout << " Не удалось открыть файл " << name << "\n"; // вывод на экран сообщения об ошибке
        return; // завершение работы функции
    }
    float tsize; // временная переменная для кол-ва элементов массива из файла
    while (filel >> tsize) // цикл для подсчёта количества элементов в файле
    {
        n++; // увеличение на 1
    }
    filel.clear(); // "очищение" состояния файлового потока
    filel.seekg(0); // перемещение указателя на начало файла
    array_num.resize(n); // изменяем размер массива
    for (size_t i = 0; i < array_num.size(); i++) // цикл для перемещения по файлу
    {
        filel >> array_num[i]; // считывание элементов массива из файла во временный массив
    }
    filel.close(); // закрытие файла
}

/// Проверяет выполнение функции sum_array на правильность вычислений
/// (условие должно быть обязательно верно, если нет, то программа прервёт свою дальнейшую работу и выведет сообщение об ошибке)
void test(){
float* testarr1 = new float[3]; // создаём тестовый массив с тремя элементами
testarr1[0]=1; // первый элемент массива
testarr1[1]=2; // второй элемент массива
testarr1[2]=3; // третий элемент массива
assert( abs( sum_array(testarr1, 3) - 1.95084) < 0.0001); // проверяем на правильность вычисление по формуле с элементами массива testarr1 (|функция (массив, кол-во элементов в массиве)-результат|<погрешность вычислений)
float* testarr2 = new float[2]; // создаём тестовый массив с двумя элементами
testarr2[0]=2; // первый элемент массива
testarr2[1]=4; // второй элемент массива
assert( abs( sum_array(testarr2, 2) - 4.34315 ) < 0.0001 ); // проверяем на правильность вычисление по формуле с элементами массива testarr2 (|функция (массив, кол-во элементов в массиве)-результат|<погрешность вычислений)
float* testarr3 = new float[4]; // создаём тестовый массив с четырьмя элементами
testarr3[0]=1; // первый элемент массива
testarr3[1]=8; // второй элемент массива
testarr3[2]=2; // третий элемент массива
testarr3[3]=4; // четвёртый элемент массива
assert( abs( sum_array(testarr3, 4) - 31.08831) < 0.0001 ); // проверяем на правильность вычисление по формуле с элементами массива testarr3 (|функция (массив, кол-во элементов в массиве)-результат|<погрешность вычислений)
delete[] testarr1; // освобождение памяти, которую занимал массив testarr1
delete[] testarr2; // освобождение памяти, которую занимал массив testarr2
delete[] testarr3; // освобождение памяти, которую занимал массив testarr3
}
}